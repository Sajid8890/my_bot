<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto RSI Monitor</title>
    <style>
        * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background: #f4f7f9;
    color: #333;
    padding: 20px;
}

.container {
    max-width: 1000px;
    margin: 0 auto;
    background: white;
    padding: 25px;
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.08);
}

h1 {
    margin-bottom: 20px;
    color: #2c3e50;
    text-align: center;
}

.controls {
    margin-bottom: 10px;
    display: flex;
    gap: 15px;
    align-items: center;
    flex-wrap: wrap;
}

.notification-controls {
    margin-bottom: 15px;
    padding: 10px;
    background-color: #f8f9fa;
    border-radius: 5px;
    display: flex;
    align-items: center;
    gap: 10px;
}
.notification-controls label {
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
}
.notification-controls input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
}

#coinsCount {
    font-size: 14px;
    color: #555;
    background-color: #ecf0f1;
    padding: 8px 12px;
    border-radius: 5px;
}

button {
    padding: 10px 18px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    color: white;
    transition: background-color 0.2s ease;
}

#startBtn { background: #2ecc71; }
#startBtn:hover:not(:disabled) { background: #27ae60; }

#stopBtn { background: #e74c3c; }
#stopBtn:hover:not(:disabled) { background: #c0392b; }

#copyBtn { background: #9b59b6; }
#copyBtn:hover:not(:disabled) { background: #8e44ad; }

button:disabled {
    background: #bdc3c7;
    cursor: not-allowed;
}

.status {
    padding: 12px;
    margin-bottom: 20px;
    background: #e7f3ff;
    border-left: 4px solid #3498db;
    border-radius: 4px;
    font-size: 14px;
    color: #333;
}

.filters {
    margin-bottom: 15px;
    display: flex;
    gap: 10px;
    align-items: center;
}

.sort-btn {
    padding: 8px 12px;
    background: #ecf0f1;
    color: #333;
    border: 1px solid #bdc3c7;
    font-size: 13px;
}

.sort-btn:hover { background: #dfe6e9; }

.sort-btn.active {
    background: #3498db;
    color: white;
    border-color: #3498db;
}

table {
    width: 100%;
    border-collapse: collapse;
    font-size: 14px;
    margin-bottom: 30px; /* Space for notified section */
}

th, td {
    padding: 12px 15px;
    text-align: left;
    border-bottom: 1px solid #ecf0f1;
}

th {
    background: #f9fafb;
    font-weight: bold;
    color: #333;
}

.select-col { width: 60px; text-align: center; }
.select-cell { text-align: center; }
.select-cell input[type="checkbox"] { width: 18px; height: 18px; cursor: pointer; }

tbody tr:hover { background: #f9f9f9; }

tbody tr.updating {
    background: #fff5f5;
    border-left: 3px solid #e74c3c;
}

.sn { width: 50px; text-align: center; color: #999; }
.coin-link { font-weight: bold; color: #3498db; text-decoration: none; }
.coin-link:hover { text-decoration: underline; }
.rsi-high { color: #e74c3c; font-weight: bold; }
.rsi-low { color: #2ecc71; font-weight: bold; }
.positive { color: #2ecc71; font-weight: bold; }
.negative { color: #e74c3c; font-weight: bold; }

/* NEW: Notified Coins Section Styles */
.notified-container {
    margin-top: 20px;
    padding: 20px;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    background-color: #fafafa;
}
.notified-container h2 {
    margin-bottom: 5px;
}
.notified-container p {
    font-size: 13px;
    color: #666;
    margin-bottom: 15px;
}
.notified-list {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
}
.notified-item {
    display: flex;
    align-items: center;
    gap: 8px;
    background-color: #e74c3c;
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 14px;
    font-weight: bold;
}
.reset-notified-btn {
    background: white;
    color: #e74c3c;
    border: none;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    cursor: pointer;
    font-weight: bold;
    line-height: 20px;
    text-align: center;
}

    </style>
</head>
<body>
    <div class="container">
        <h1>Crypto RSI Monitor</h1>
        <div class="controls">
            <span id="coinsCount">Loading...</span>
            <button id="startBtn">Start Monitoring</button>
            <button id="stopBtn" disabled>Stop Monitoring</button>
            <button id="copyBtn" class="secondary-btn" disabled>Copy Selected</button>
        </div>
        <div class="notification-controls">
            <input type="checkbox" id="notifyToggle">
            <label for="notifyToggle">Notify on RSI > 80</label>
        </div>
        <div id="status" class="status">Ready to start</div>
        
        <div class="filters">
            <span>Sort by:</span>
            <button class="sort-btn active" data-sort="rsi">RSI (High to Low)</button>
            <button class="sort-btn" data-sort="change24h">24h Change (High to Low)</button>
        </div>
        
        <table id="coinsTable">
            <thead>
                <tr>
                    <th class="select-col">Select</th>
                    <th>#</th>
                    <th>Coin Pair</th>
                    <th>Current Price</th>
                    <th>24h Change %</th>
                    <th>RSI (14)</th>
                </tr>
            </thead>
            <tbody id="tableBody">
                <!-- Main coin data will be inserted here -->
            </tbody>
        </table>

        <!-- NEW: Notified Coins Section -->
        <div id="notifiedSection" class="notified-container" style="display: none;">
            <h2>Alert History (RSI > 80)</h2>
            <p>Coins listed here will not trigger new notifications. Click "Reset" to re-enable alerts for a specific coin.</p>
            <div id="notifiedList" class="notified-list">
                <!-- Notified coins will be dynamically inserted here -->
            </div>
        </div>
    </div>
    <script>
        const state = {
    allCoins: [],
    data: new Map(),
    isRunning: false,
    isRsiLoopActive: false,
    currentUpdatingCoin: null,
    wsConnections: new Map(),
    rsiMonitorTimer: null,
    backgroundFilterTimer: null,
    notificationsEnabled: false,
    // No longer need in-memory set, localStorage is the source of truth
};

const config = {
    RSI_LENGTH: 14,
    timeframe: '1h',
    rsiLimit: 100,
    apiEndpoint: 'https://fapi.binance.com/fapi/v1/klines',
    ticker24hEndpoint: 'https://fapi.binance.com/fapi/v1/ticker/24hr',
    wsEndpoint: 'wss://fstream.binance.com/ws',
    coinsFilePath: './coins.txt',
    priceChangeThreshold: 10.0,
    rsiInterval: 250,
    sortBy: 'rsi',
    httpFilterBatchSize: 100,
    httpFilterBatchDelay: 100,
    backgroundFilterInterval: 120000,
    rsiNotificationThreshold: 80
};

// --- CORE LOGIC & NOTIFICATIONS ---

function startMonitoring( ) {
    if (state.isRunning) return;
    state.isRunning = true;
    state.isRsiLoopActive = false;
    // Clear in-memory data, but localStorage persists
    state.data.clear();

    document.getElementById('startBtn').disabled = true;
    document.getElementById('stopBtn').disabled = false;
    document.getElementById('copyBtn').disabled = false;
    
    initializeTable();
    loadNotifiedCoinsFromStorage(); // Load and display persisted alerts
    runInitialFilterScan();
}

function stopMonitoring() {
    state.isRunning = false;
    clearTimeout(state.rsiMonitorTimer);
    clearTimeout(state.backgroundFilterTimer);
    [...state.wsConnections.keys()].forEach(disconnectWebSocket);
    state.wsConnections.clear();
    setActiveCoin(null);
    document.getElementById('startBtn').disabled = false;
    document.getElementById('stopBtn').disabled = true;
    document.getElementById('copyBtn').disabled = true;
    updateStatus('Stopped', 'idle');
}

function copySelectedCoins() {
    const checkboxes = document.querySelectorAll('.coin-checkbox:checked');
    if (checkboxes.length === 0) { alert("No coins selected."); return; }
    const coinList = Array.from(checkboxes).map(cb => cb.dataset.coin);
    navigator.clipboard.writeText(coinList.join('\n')).then(() => alert(`${coinList.length} coin(s) copied!`));
}

async function handleNotificationToggle(event) {
    if (event.target.checked) {
        if (!("Notification" in window)) {
            alert("This browser does not support notifications.");
            event.target.checked = false;
            return;
        }
        if (Notification.permission === "granted") {
            state.notificationsEnabled = true;
        } else if (Notification.permission !== "denied") {
            const permission = await Notification.requestPermission();
            if (permission === "granted") {
                state.notificationsEnabled = true;
                new Notification("RSI Alerts Activated!");
            } else {
                event.target.checked = false;
            }
        } else {
            alert("Notification permission was denied. You must enable it in browser settings.");
            event.target.checked = false;
        }
    } else {
        state.notificationsEnabled = false;
    }
}

function sendNotification(coin, rsi) {
    const notifiedCoins = getNotifiedCoinsFromStorage();
    if (!state.notificationsEnabled || notifiedCoins.includes(coin)) {
        return;
    }

    const title = `${coin} RSI Alert!`;
    const body = `RSI has crossed ${config.rsiNotificationThreshold} and is now ${rsi.toFixed(2)}.`;
    new Notification(title, { body });
    
    // Add to localStorage and update UI
    addCoinToNotifiedList(coin);
}

// --- LOCALSTORAGE & NOTIFIED LIST MANAGEMENT ---

function getNotifiedCoinsFromStorage() {
    return JSON.parse(localStorage.getItem('notifiedRsiCoins') || '[]');
}

function saveNotifiedCoinsToStorage(coins) {
    localStorage.setItem('notifiedRsiCoins', JSON.stringify(coins));
}

function addCoinToNotifiedList(coin) {
    const notifiedCoins = getNotifiedCoinsFromStorage();
    if (!notifiedCoins.includes(coin)) {
        notifiedCoins.push(coin);
        saveNotifiedCoinsToStorage(notifiedCoins);
        renderNotifiedList(); // Update the UI
    }
}

function removeCoinFromNotifiedList(coinToRemove) {
    let notifiedCoins = getNotifiedCoinsFromStorage();
    notifiedCoins = notifiedCoins.filter(coin => coin !== coinToRemove);
    saveNotifiedCoinsToStorage(notifiedCoins);
    renderNotifiedList(); // Update the UI
}

function renderNotifiedList() {
    const notifiedCoins = getNotifiedCoinsFromStorage();
    const listContainer = document.getElementById('notifiedList');
    const sectionContainer = document.getElementById('notifiedSection');
    listContainer.innerHTML = '';

    if (notifiedCoins.length > 0) {
        sectionContainer.style.display = 'block';
        notifiedCoins.forEach(coin => {
            const item = document.createElement('div');
            item.className = 'notified-item';
            item.innerHTML = `
                <span>${coin}</span>
                <button class="reset-notified-btn" data-coin="${coin}" title="Reset alert for ${coin}">Ã—</button>
            `;
            listContainer.appendChild(item);
        });
    } else {
        sectionContainer.style.display = 'none';
    }
}

function loadNotifiedCoinsFromStorage() {
    renderNotifiedList();
}

// --- PROCESSES & LOOPS ---

async function runInitialFilterScan() {
    updateStatus(`Performing fast initial scan...`, 'filtering');
    const eligibleCoins = await fetchAllCoinsForFilter();
    if (eligibleCoins.length > 0) {
        addNewCoinsToTable(eligibleCoins);
        if (!state.isRsiLoopActive) {
            state.isRsiLoopActive = true;
            monitorRSI();
        }
    }
    updateStatus(`Scan complete. Monitoring ${document.getElementById('tableBody').rows.length} coins.`, 'monitoring');
    if (state.isRunning) {
        state.backgroundFilterTimer = setTimeout(runBackgroundRefresh, config.backgroundFilterInterval);
    }
}

async function runBackgroundRefresh() {
    if (!state.isRunning) return;
    const eligibleCoins = await fetchAllCoinsForFilter();
    const eligibleSet = new Set(eligibleCoins);
    const currentlyDisplayedSet = new Set(getSortedCoins());
    const toAdd = eligibleCoins.filter(c => !currentlyDisplayedSet.has(c));
    const toRemove = [...currentlyDisplayedSet].filter(c => !eligibleSet.has(c));
    if (toAdd.length > 0) addNewCoinsToTable(toAdd);
    if (toRemove.length > 0) removeCoinsFromTable(toRemove);
    state.backgroundFilterTimer = setTimeout(runBackgroundRefresh, config.backgroundFilterInterval);
}

async function monitorRSI() {
    if (!state.isRunning) return;
    const coinArray = getSortedCoins();
    if (coinArray.length === 0) {
        state.rsiMonitorTimer = setTimeout(monitorRSI, 5000);
        return;
    }
    for (const coin of coinArray) {
        if (!state.isRunning) return;
        setActiveCoin(coin);
        updateStatus(`RSI for ${coin} (${coinArray.indexOf(coin) + 1}/${coinArray.length})`, 'monitoring');
        await fetchRSI(coin);
        await new Promise(resolve => setTimeout(resolve, config.rsiInterval));
    }
    resortTable();
    state.rsiMonitorTimer = setTimeout(monitorRSI, 100);
}

// --- DATA FETCHING ---

async function fetchAllCoinsForFilter() {
    const eligible = [];
    for (let i = 0; i < state.allCoins.length; i += config.httpFilterBatchSize ) {
        if (!state.isRunning) break;
        const batch = state.allCoins.slice(i, i + config.httpFilterBatchSize );
        await Promise.all(batch.map(async (coin) => {
            const data = await fetch24hChangeInitial(coin);
            if (data && data.change24h >= config.priceChangeThreshold) eligible.push(coin);
        }));
        updateStatus(`Scanning... (${Math.min(i + config.httpFilterBatchSize, state.allCoins.length )}/${state.allCoins.length})`, 'filtering');
        await new Promise(resolve => setTimeout(resolve, config.httpFilterBatchDelay ));
    }
    return eligible;
}

async function fetch24hChangeInitial(coin) {
    try {
        const response = await fetch(`${config.ticker24hEndpoint}?symbol=${coin}`);
        if (!response.ok) return null;
        const data = await response.json();
        const price = parseFloat(data.lastPrice), change24h = parseFloat(data.priceChangePercent);
        state.data.set(coin, { ...state.data.get(coin), price, change24h });
        return { price, change24h };
    } catch (error) { return null; }
}

async function fetchRSI(coin) {
    try {
        const params = new URLSearchParams({ symbol: coin, interval: config.timeframe, limit: config.rsiLimit });
        const response = await fetch(`${config.apiEndpoint}?${params}`);
        if (!response.ok) throw new Error(`API error ${response.status}`);
        const klines = await response.json();
        if (!klines || !Array.isArray(klines) || klines.length < config.RSI_LENGTH) throw new Error('Not enough data');
        const prices = klines.map(k => parseFloat(k[4]));
        const rsi = calculateRSI(prices);
        state.data.set(coin, { ...state.data.get(coin), rsi });
        updateRSIRow(coin, rsi);
        if (rsi >= config.rsiNotificationThreshold) {
            sendNotification(coin, rsi);
        } else {
            // If RSI drops, it's eligible for notification again.
            removeCoinFromNotifiedList(coin);
        }
    } catch (error) {
        console.error(`RSI Error for ${coin}:`, error.message);
        updateRSIRow(coin, null);
    }
}

function calculateRSI(prices) {
    if (prices.length < config.RSI_LENGTH + 1) return null;
    let gains = 0, losses = 0;
    for (let i = 1; i <= config.RSI_LENGTH; i++) {
        const diff = prices[i] - prices[i - 1];
        if (diff >= 0) gains += diff; else losses -= diff;
    }
    let avgGain = gains / config.RSI_LENGTH, avgLoss = losses / config.RSI_LENGTH;
    for (let i = config.RSI_LENGTH + 1; i < prices.length; i++) {
        const diff = prices[i] - prices[i - 1];
        if (diff >= 0) {
            avgGain = (avgGain * (config.RSI_LENGTH - 1) + diff) / config.RSI_LENGTH;
            avgLoss = (avgLoss * (config.RSI_LENGTH - 1)) / config.RSI_LENGTH;
        } else {
            avgGain = (avgGain * (config.RSI_LENGTH - 1)) / config.RSI_LENGTH;
            avgLoss = (avgLoss * (config.RSI_LENGTH - 1) - diff) / config.RSI_LENGTH;
        }
    }
    if (avgLoss === 0) return 100;
    const rs = avgGain / avgLoss;
    return 100 - (100 / (1 + rs));
}

// --- WEBSOCKETS (On-Demand) ---

function connectWebSocket(coin) {
    if (!state.isRunning || state.wsConnections.has(coin)) return;
    const ws = new WebSocket(`${config.wsEndpoint}/${coin.toLowerCase()}@ticker`);
    state.wsConnections.set(coin, ws);
    ws.onmessage = (event) => {
        try {
            const data = JSON.parse(event.data);
            const price = parseFloat(data.c), change24h = parseFloat(data.P);
            state.data.set(coin, { ...state.data.get(coin), price, change24h });
            updatePriceRow(coin);
        } catch (error) { console.error(`WS Error for ${coin}:`, error); }
    };
    ws.onerror = (error) => console.error(`WS Error for ${coin}:`, error.message || error);
    ws.onclose = () => {
        state.wsConnections.delete(coin);
        if (state.isRunning && document.getElementById(`row-${coin}`)) {
            setTimeout(() => connectWebSocket(coin), 5000);
        }
    };
}

function disconnectWebSocket(coin) {
    const ws = state.wsConnections.get(coin);
    if (ws) {
        ws.onclose = null;
        ws.close();
        console.log(`- WS connection closed for: ${coin}`);
    }
}

// --- UI & DOM MANIPULATION ---

function initializeTable() { document.getElementById('tableBody').innerHTML = ''; }

function addNewCoinsToTable(coins) {
    const tbody = document.getElementById('tableBody');
    coins.forEach(coin => {
        if (document.getElementById(`row-${coin}`)) return;
        const row = document.createElement('tr');
        row.id = `row-${coin}`;
        row.innerHTML = `
            <td class="select-cell"><input type="checkbox" class="coin-checkbox" data-coin="${coin}" checked></td>
            <td class="sn">-</td>
            <td class="coin-name"><a href="https://www.binance.com/en/futures/${coin}" target="_blank" class="coin-link">${coin}</a></td>
            <td class="price">-</td>
            <td class="change24h">-</td>
            <td class="rsi">...</td>
        `;
        tbody.appendChild(row );
        updatePriceRow(coin);
        connectWebSocket(coin);
        // Fetch RSI immediately for real-time alert check
        fetchRSI(coin);
    });
    resortTable();
}

function removeCoinsFromTable(coins) {
    coins.forEach(coin => {
        const row = document.getElementById(`row-${coin}`);
        if (row) row.remove();
        disconnectWebSocket(coin);
    });
    resortTable();
}

function updatePriceRow(coin) {
    const row = document.getElementById(`row-${coin}`);
    if (!row) return;
    const data = state.data.get(coin);
    if (!data) return;
    const priceCell = row.querySelector('.price'), changeCell = row.querySelector('.change24h');
    if (data.price) priceCell.textContent = data.price.toFixed(Math.max(2, 8 - Math.floor(Math.log10(data.price) || 0)));
    if (data.change24h !== null) {
        changeCell.textContent = data.change24h.toFixed(2) + '%';
        changeCell.className = data.change24h >= 0 ? 'change24h positive' : 'change24h negative';
    }
}

function updateRSIRow(coin, rsi) {
    const row = document.getElementById(`row-${coin}`);
    if (!row) return;
    const rsiCell = row.querySelector('.rsi');
    if (rsi !== null) {
        rsiCell.textContent = rsi.toFixed(2);
        rsiCell.className = rsi > 70 ? 'rsi rsi-high' : rsi < 30 ? 'rsi rsi-low' : 'rsi';
    } else {
        rsiCell.textContent = '...';
        rsiCell.className = 'rsi';
    }
}

function getSortedCoins() {
    const rows = Array.from(document.getElementById('tableBody').querySelectorAll('tr'));
    const coins = rows.map(row => row.id.replace('row-', ''));
    coins.sort((a, b) => {
        const dataA = state.data.get(a) || {}, dataB = state.data.get(b) || {};
        if (config.sortBy === 'rsi') return (dataB.rsi ?? -1) - (dataA.rsi ?? -1);
        if (config.sortBy === 'change24h') return (dataB.change24h ?? -Infinity) - (dataA.change24h ?? -Infinity);
        return 0;
    });
    return coins;
}

function resortTable() {
    const tbody = document.getElementById('tableBody');
    const sortedCoins = getSortedCoins();
    sortedCoins.forEach(coin => {
        const row = document.getElementById(`row-${coin}`);
        if (row) tbody.appendChild(row);
    });
    renumberRows();
}

function renumberRows() {
    const rows = document.getElementById('tableBody').querySelectorAll('tr');
    rows.forEach((row, index) => { row.querySelector('.sn').textContent = index + 1; });
}

function setActiveCoin(coin) {
    if (state.currentUpdatingCoin) {
        const prevRow = document.getElementById(`row-${state.currentUpdatingCoin}`);
        if (prevRow) prevRow.classList.remove('updating');
    }
    state.currentUpdatingCoin = coin;
    if (coin) {
        const currentRow = document.getElementById(`row-${coin}`);
        if (currentRow) currentRow.classList.add('updating');
    }
}

function setSortBy(sortType) {
    config.sortBy = sortType;
    document.querySelectorAll('.sort-btn').forEach(btn => btn.classList.remove('active'));
    document.querySelector(`[data-sort="${sortType}"]`).classList.add('active');
    resortTable();
}

function updateStatus(msg, phase) { document.getElementById('status').textContent = `[${phase.toUpperCase()}] ${msg}`; }

// --- INITIALIZATION ---

async function loadCoinsFile() {
    try {
        const response = await fetch(config.coinsFilePath);
        if (!response.ok) throw new Error('File not found');
        const text = await response.text();
        state.allCoins = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
        return state.allCoins.length;
    } catch (error) {
        console.error('Error loading coins.txt:', error);
        alert('Failed to load coins.txt. Please ensure it is in the same folder as index.html.');
        return 0;
    }
}

window.addEventListener('DOMContentLoaded', async () => {
    const count = await loadCoinsFile();
    if (count > 0) {
        document.getElementById('coinsCount').textContent = `${count} coins loaded`;
        updateStatus(`Loaded ${count} coins`, 'ready');
    }
    // Load notified coins from storage on page load
    loadNotifiedCoinsFromStorage();
});

document.getElementById('startBtn').addEventListener('click', startMonitoring);
document.getElementById('stopBtn').addEventListener('click', stopMonitoring);
document.getElementById('copyBtn').addEventListener('click', copySelectedCoins);
document.getElementById('notifyToggle').addEventListener('change', handleNotificationToggle);
document.querySelectorAll('.sort-btn').forEach(btn => btn.addEventListener('click', () => setSortBy(btn.dataset.sort)));

// Add event listener for the reset buttons using event delegation
document.getElementById('notifiedList').addEventListener('click', (event) => {
    if (event.target.classList.contains('reset-notified-btn')) {
        const coin = event.target.dataset.coin;
        removeCoinFromNotifiedList(coin);
    }
});


    </script>
</body>
</html>

